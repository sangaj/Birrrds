grid_space = data_grid_new.select('location_index','dt','count').withColumn('dt', F.date_format('dt', 'yyyy-MM-dd HH:mm:ss'))
grid_space = grid_space.groupBy('dt').pivot('location_index').avg('count').fillna(0)

grid_dt = grid_space.select('dt')
grid_dt_repeat = grid_dt.map(lambda x: np.repeat(x, 8))
grid_trans = grid_space.drop(grid_space.dt).persist()
trans = grid_trans.map(lambda x: transform(x))



def sliding_window(arr, window_size):
    """ Construct a sliding window view of the array"""
    arr = np.asarray(arr)
    window_size = int(window_size)
    if arr.ndim != 2:
        raise ValueError("need 2-D input")
    if not (window_size > 0):
        raise ValueError("need a positive window size")
    shape = (arr.shape[0] - window_size + 1,
             arr.shape[1] - window_size + 1,
             window_size, window_size)
    if shape[0] <= 0:
        shape = (1, shape[1], arr.shape[0], shape[3])
    if shape[1] <= 0:
        shape = (shape[0], 1, shape[2], arr.shape[1])
    strides = (arr.shape[1]*arr.itemsize, arr.itemsize,
               arr.shape[1]*arr.itemsize, arr.itemsize)
    return as_strided(arr, shape=shape, strides=strides)

def cell_neighbors(arr, i, j):
    """Return 1-th neighbors of cell (i, j)"""
    w = sliding_window(arr, 2*1+1)

    ix = np.clip(i - 1, 0, w.shape[0]-1)
    jx = np.clip(j - 1, 0, w.shape[1]-1)

    i0 = max(0, i - 1 - ix)
    j0 = max(0, j - 1 - jx)
    i1 = w.shape[2] - max(0, 1 - i + ix)
    j1 = w.shape[3] - max(0, 1 - j + jx)

    return w[ix, jx][i0:i1,j0:j1].ravel()


def transform(arr): 
    neighboor = []
    for i in range(1, 5):
         for j in range(1, 3):
            neighboor.append(cell_neighbors(np.array(arr).reshape(6,4), i, j))
    neighboor = np.array(neighboor)
    location = ("loc22","loc23","loc32","loc33","loc42","loc43","loc52","loc53")
    location = np.array(location)
    neighboor = np.c_[location,neighboor] 
    return neighboor
    
    
 def transform(arr): 
    submatrix = []
    for i in range(0,4):
        for j in range(0,2):
            submatrix.append((arr.reshape(6,4)[i:i+3,j:j+3]).flatten())
    submatrix = np.array(submatrix)
    location = ("loc22","loc23","loc32","loc33","loc42","loc43","loc52","loc53")
    location = np.array(location)
    neighboor = np.c_[location,submatrix]
    neighboor = pd.DataFrame(neighboor)
    return neighboor
    
grid_dt = grid_space.select('dt').toPandas()
grid_dt_repeat = grid_dt.apply(lambda x: np.repeat(x, 8))
grid_trans = grid_space.drop(grid_space.dt).toPandas()
transform = grid_trans.apply(lambda x: transform(x),axis=1)


submatrix = []
for i in range(0,4):
        for j in range(0,2):
            submatrix.append(grid_trans.iloc[3].reshape(6,4)[i:i+3,j:j+3].flatten())
submatrix= np.array(submatrix)
location = ("loc22","loc23","loc32","loc33","loc42","loc43","loc52","loc53")
location = np.array(location)
neighboor = np.c_[location,submatrix]
neighboor = pd.DataFrame(neighboor)
print neighboor
